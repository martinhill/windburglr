<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>windburglr - {{ station }}</title>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
        <link rel="stylesheet" href="/static/style.css" />
    </head>
    <body>
        <!-- Mobile orientation popup -->
        <div id="orientation-popup" class="orientation-popup hidden">
            <div class="orientation-popup-content">
                <div class="rotate-icon">üì±‚Üª</div>
                <h3>Better Experience</h3>
                <p>For the best viewing experience of wind charts, please rotate your device to landscape orientation.</p>
                <button class="btn" onclick="dismissOrientationPopup()">Got it!</button>
            </div>
        </div>

        <div class="container">
            <header>
                <div class="header-content-outer">
                    <div class="header-content">
                        <div class="title-section">
                            {% if is_live %}
                            <span class="station"
                                >{{ station }} currently:</span
                            >
                            {% else %}
                            <span class="station"
                                >{{ station }} on
                                <span id="formatted-date"
                                    >{{ selected_date }}</span
                                ></span
                            >
                            {% endif %}
                        </div>
                        {% if is_live %}
                        <div class="current-conditions-compact">
                            <div class="condition-compact">
                                <span class="value" id="current-speed">--</span>
                                <span class="label">kts</span>
                            </div>
                            <div class="condition-compact">
                                <span class="value" id="current-direction"
                                    >--</span
                                >
                            </div>
                            <div class="condition-compact">
                                <span class="value" id="current-gust">--</span>
                                <span class="label">gust</span>
                            </div>
                            <div class="condition-compact">
                                <span class="value" id="last-update">--</span>
                            </div>
                        </div>
                        {% endif %}
                    </div>
                    <div
                        class="connection-indicator"
                        id="connection-status"
                        title="Connecting..."
                    ></div>
                </div>
            </header>

            <div class="content-wrapper">
                <div class="charts-container">
                    <div class="chart-section">
                        <!-- <h3>Wind Speed & Direction (Last {{ hours }} hours)</h3> -->
                        <canvas id="windChart"></canvas>
                    </div>
                </div>

                <div class="controls">
                    {% if is_live %}
                    <button id="toggle-realtime" class="btn">
                        Pause Real-time Updates
                    </button>
                    <select id="time-range">
                        <option value="1">Last 1 hour</option>
                        <option value="3" selected>Last 3 hours</option>
                        <option value="6">Last 6 hours</option>
                        <option value="12">Last 12 hours</option>
                        <option value="24">Last 24 hours</option>
                    </select>
                    <button id="reset-zoom" class="btn" style="display: none">
                        Reset Zoom
                    </button>
                    <button id="view-yesterday" class="btn">
                        View Yesterday
                    </button>
                    {% else %}
                    <div class="date-navigation">
                        <button
                            id="prev-date"
                            class="btn"
                            onclick="navigateToDate('{{ prev_date }}')"
                        >
                            ‚Üê Previous Day
                        </button>
                        <input
                            type="date"
                            id="date-picker"
                            value="{{ selected_date }}"
                            onchange="navigateToDate(this.value)"
                        />
                        <button
                            id="next-date"
                            class="btn"
                            onclick="navigateToDate('{{ next_date }}')"
                        >
                            Next Day ‚Üí
                        </button>
                        <button
                            id="reset-zoom"
                            class="btn"
                            style="display: none"
                        >
                            Reset Zoom
                        </button>
                        <a href="/" class="btn">Back to Live</a>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <script>
                const STATION = '{{ station }}';
                const IS_LIVE = {{ is_live|lower }};
                const DIRECTIONS = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                {% if not is_live %}
                const DATE_START = '{{ date_start }}';
                const DATE_END = '{{ date_end }}';
                {% endif %}

                let windChart;
                let websocket;
                let realtimeEnabled = true;
                let windData = [];
                let lastObservationTime = null;
                let currentTimeWindowHours = 3;

                // Zoom functionality variables
                let isZooming = false;
                let zoomStartX = null;
                let zoomOverlay = null;
                let originalTimeRange = null;

                function navigateToDate(date) {
                    const currentParams = new URLSearchParams(window.location.search);
                    const stn = currentParams.get('stn') || '{{ station }}';
                    window.location.href = `/date/${date}?stn=${stn}`;
                }

                function getDirectionText(degrees) {
                    if (degrees === null || degrees === undefined) return '--';
                    const index = Math.round(degrees / 22.5) % 16;
                    return DIRECTIONS[index];
                }

                function formatTime(timestamp) {
                    return new Date(timestamp * 1000).toLocaleTimeString();
                }

                function formatDateTime(timestamp) {
                    return new Date(timestamp * 1000).toLocaleString();
                }

                function filterOldObservations(data) {
                    if (!IS_LIVE || currentTimeWindowHours <= 0) {
                        return data;
                    }
                    
                    const now = Date.now() / 1000; // Current time in seconds
                    const cutoffTime = now - (currentTimeWindowHours * 3600); // Hours to seconds
                    
                    return data.filter(point => point[0] >= cutoffTime);
                }

                function isMobileDevice() {
                    return window.innerWidth <= 768 && 'ontouchstart' in window;
                }

                function isPortraitOrientation() {
                    return window.innerHeight > window.innerWidth;
                }

                function hasSeenOrientationPopup() {
                    return localStorage.getItem('windburglr-orientation-popup-seen') === 'true';
                }

                function markOrientationPopupSeen() {
                    localStorage.setItem('windburglr-orientation-popup-seen', 'true');
                }

                function showOrientationPopup() {
                    const popup = document.getElementById('orientation-popup');
                    if (popup) {
                        popup.classList.remove('hidden');
                    }
                }

                function hideOrientationPopup() {
                    const popup = document.getElementById('orientation-popup');
                    if (popup) {
                        popup.classList.add('hidden');
                    }
                }

                function dismissOrientationPopup() {
                    hideOrientationPopup();
                    markOrientationPopupSeen();
                }

                // Make dismissOrientationPopup globally accessible
                window.dismissOrientationPopup = dismissOrientationPopup;

                function checkOrientationPopup() {
                    if (isMobileDevice() && isPortraitOrientation() && !hasSeenOrientationPopup()) {
                        // Show popup after a short delay to let the page load
                        setTimeout(showOrientationPopup, 1000);
                    }
                }

                function updateCurrentConditions(data) {
                    document.getElementById('current-speed').textContent = data.speed_kts || '--';
                    document.getElementById('current-direction').textContent = getDirectionText(data.direction);
                    document.getElementById('current-gust').textContent = data.gust_kts || '--';
                    document.getElementById('last-update').textContent = formatTime(data.timestamp);

                    // Track the most recent observation time
                    if (data.timestamp && (!lastObservationTime || data.timestamp > lastObservationTime)) {
                        lastObservationTime = data.timestamp;
                    }
                }

                function createZoomOverlay() {
                    const canvas = document.getElementById('windChart');
                    const rect = canvas.getBoundingClientRect();

                    zoomOverlay = document.createElement('div');
                    zoomOverlay.style.position = 'absolute';
                    zoomOverlay.style.backgroundColor = 'rgba(102, 126, 234, 0.2)';
                    zoomOverlay.style.border = '1px solid rgba(102, 126, 234, 0.5)';
                    zoomOverlay.style.pointerEvents = 'none';
                    zoomOverlay.style.zIndex = '1000';
                    zoomOverlay.style.display = 'none';

                    canvas.parentElement.style.position = 'relative';
                    canvas.parentElement.appendChild(zoomOverlay);
                }

                function updateZoomOverlay(startX, currentX) {
                    if (!zoomOverlay) return;

                    const canvas = document.getElementById('windChart');
                    const rect = canvas.getBoundingClientRect();
                    const chartArea = windChart.chartArea;

                    const left = Math.min(startX, currentX);
                    const width = Math.abs(currentX - startX);

                    zoomOverlay.style.left = `${left - rect.left}px`;
                    zoomOverlay.style.top = `${chartArea.top}px`;
                    zoomOverlay.style.width = `${width}px`;
                    zoomOverlay.style.height = `${chartArea.bottom - chartArea.top}px`;
                    zoomOverlay.style.display = 'block';
                }

                function hideZoomOverlay() {
                    if (zoomOverlay) {
                        zoomOverlay.style.display = 'none';
                    }
                }

                function performZoom(startX, endX) {
                    const canvas = document.getElementById('windChart');
                    const rect = canvas.getBoundingClientRect();
                    const chartArea = windChart.chartArea;

                    // Convert pixel coordinates to data coordinates
                    const startDataX = windChart.scales.x.getValueForPixel(startX - rect.left);
                    const endDataX = windChart.scales.x.getValueForPixel(endX - rect.left);

                    if (!startDataX || !endDataX) return;

                    // Store original range if this is the first zoom
                    if (!originalTimeRange && windChart.data.labels.length > 0) {
                        originalTimeRange = {
                            min: windChart.data.labels[0],
                            max: windChart.data.labels[windChart.data.labels.length - 1]
                        };
                    }

                    // Set new time range
                    const minTime = Math.min(startDataX, endDataX);
                    const maxTime = Math.max(startDataX, endDataX);

                    windChart.options.scales.x.min = minTime;
                    windChart.options.scales.x.max = maxTime;
                    windChart.update();

                    // Show reset zoom button
                    const resetButton = document.getElementById('reset-zoom');
                    if (resetButton) {
                        resetButton.style.display = 'inline-block';
                    }
                }

                function resetZoom() {
                    if (originalTimeRange) {
                        windChart.options.scales.x.min = originalTimeRange.min;
                        windChart.options.scales.x.max = originalTimeRange.max;
                    } else {
                        delete windChart.options.scales.x.min;
                        delete windChart.options.scales.x.max;
                    }
                    windChart.update();

                    // Hide reset zoom button
                    const resetButton = document.getElementById('reset-zoom');
                    if (resetButton) {
                        resetButton.style.display = 'none';
                    }
                }

                function initCharts() {
                    const ctx = document.getElementById('windChart').getContext('2d');

                    windChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Wind Speed (kts)',
                                data: [],
                                borderColor: 'rgb(0, 168, 240)',
                                backgroundColor: 'rgba(0, 168, 240, 0.1)',
                                tension: 0.3,
                                fill: true,
                                yAxisID: 'y'
                            }, {
                                label: 'Gust (kts)',
                                data: [],
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                tension: 0.1,
                                fill: false,
                                yAxisID: 'y'
                            }, {
                                label: 'Wind Direction',
                                data: [],
                                borderColor: 'orange',
                                // backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                pointBackgroundColor: 'orange',
                                fill: false,
                                yAxisID: 'y1',
                                showLine: false,
                                pointStyle: 'circle'
                            }]
                        },
                        options: {
                            pointStyle: false,
                            responsive: true,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'minute',
                                        stepSize: 15,
                                        displayFormats: {
                                            minute: 'HH:mm'
                                        }
                                    },
                                    ticks: {
                                        maxTicksLimit: 96,
                                        autoSkip: false,
                                        source: 'auto',
                                        callback: function(value, index, values) {
                                            const date = new Date(value);
                                            const minutes = date.getMinutes();
                                            // Only show ticks at 0, 15, 30, 45 minutes
                                            if (minutes % 15 === 0) {
                                                return date.toLocaleTimeString('en-US', {
                                                    hour: '2-digit',
                                                    minute: '2-digit',
                                                    hour12: false
                                                });
                                            }
                                            return null;
                                        }
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Speed (knots)'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    min: 0,
                                    max: 360,
                                    title: {
                                        display: true,
                                        text: 'Direction'
                                    },
                                    ticks: {
                                        stepSize: 45,
                                        callback: function(value) {
                                            return getDirectionText(value);
                                        }
                                    },
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                }
                            },
                            plugins: {
                                legend: {
                                    // display: true,
                                    position: 'bottom'
                                }
                            }
                        }
                    });

                    // Create zoom overlay
                    createZoomOverlay();

                    // Add mouse event listeners for zoom functionality
                    const canvas = document.getElementById('windChart');

                    canvas.addEventListener('mousedown', function(e) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX;
                        const chartArea = windChart.chartArea;

                        // Only start zoom if clicking within chart area
                        if (x >= rect.left + chartArea.left && x <= rect.left + chartArea.right) {
                            isZooming = true;
                            zoomStartX = x;
                            canvas.style.cursor = 'crosshair';
                        }
                    });

                    canvas.addEventListener('mousemove', function(e) {
                        if (isZooming && zoomStartX !== null) {
                            const currentX = e.clientX;
                            updateZoomOverlay(zoomStartX, currentX);
                        }
                    });

                    canvas.addEventListener('mouseup', function(e) {
                        if (isZooming && zoomStartX !== null) {
                            const endX = e.clientX;
                            const minDragDistance = 20; // Minimum pixels to consider it a zoom

                            if (Math.abs(endX - zoomStartX) > minDragDistance) {
                                performZoom(zoomStartX, endX);
                            }

                            isZooming = false;
                            zoomStartX = null;
                            hideZoomOverlay();
                            canvas.style.cursor = 'default';
                        }
                    });

                    canvas.addEventListener('mouseleave', function(e) {
                        if (isZooming) {
                            isZooming = false;
                            zoomStartX = null;
                            hideZoomOverlay();
                            canvas.style.cursor = 'default';
                        }
                    });

                    // Double-click to reset zoom
                    canvas.addEventListener('dblclick', function(e) {
                        resetZoom();
                    });
                }

            function updateCharts(data) {
                const timeData = data.map(d => new Date(d[0] * 1000));
                const speeds = data.map(d => d[2]);
                const gusts = data.map(d => d[3]);
                const directions = data.map(d => d[1]).map(d => d === null ? null : d);

                windChart.data.labels = timeData;
                windChart.data.datasets[0].data = speeds;
                windChart.data.datasets[1].data = gusts;
                windChart.data.datasets[2].data = directions;

                // Update lastObservationTime from the data
                if (data.length > 0) {
                    const latestTimestamp = Math.max(...data.map(d => d[0]));
                    if (!lastObservationTime || latestTimestamp > lastObservationTime) {
                        lastObservationTime = latestTimestamp;
                    }
                }

                // Reset zoom when new data is loaded
                delete windChart.options.scales.x.min;
                delete windChart.options.scales.x.max;
                originalTimeRange = null;

                // Hide reset zoom button
                const resetButton = document.getElementById('reset-zoom');
                if (resetButton) {
                    resetButton.style.display = 'none';
                }

                windChart.update();
            }
                async function loadHistoricalData(hours = 3) {
                    try {
                        let url;
                        if (IS_LIVE) {
                            url = `/api/wind?stn=${STATION}&hours=${hours}`;
                        } else {
                            // For date view, use specific date range
                            url = `/api/wind?stn=${STATION}&from_time=${DATE_START}&to_time=${DATE_END}`;
                        }
                        const response = await fetch(url);
                        const data = await response.json();
                        windData = data.winddata;
                        updateCharts(windData);
                    } catch (error) {
                        console.error('Error loading historical data:', error);
                    }
                }

                async function fillDataGap() {
                    if (!lastObservationTime || !IS_LIVE) {
                        console.log('No gap filling needed - no last observation time or not in live mode');
                        return;
                    }

                    try {
                        console.log('Filling data gap since:', new Date(lastObservationTime * 1000));

                        // Convert lastObservationTime to ISO format for the API
                        const fromTime = new Date(lastObservationTime * 1000).toISOString().slice(0, 19);
                        const toTime = new Date().toISOString().slice(0, 19);

                        const url = `/api/wind?stn=${STATION}&from_time=${fromTime}&to_time=${toTime}`;
                        const response = await fetch(url);
                        const data = await response.json();

                        if (data.winddata && data.winddata.length > 0) {
                            console.log(`Retrieved ${data.winddata.length} data points to fill gap`);

                            // Merge new data with existing data, avoiding duplicates
                            const newData = data.winddata.filter(newPoint => {
                                return !windData.some(existingPoint =>
                                    Math.abs(existingPoint[0] - newPoint[0]) < 1 // Within 1 second
                                );
                            });

                            if (newData.length > 0) {
                                console.log(`Adding ${newData.length} new data points after deduplication`);
                                windData = windData.concat(newData);
                                
                                // Sort by timestamp to maintain chronological order
                                windData.sort((a, b) => a[0] - b[0]);
                                
                                // Filter out observations older than the selected time window
                                windData = filterOldObservations(windData);
                                
                                // Keep only recent data (last 1000 points)
                                if (windData.length > 1000) {
                                    windData = windData.slice(-1000);
                                }
                                
                                updateCharts(windData);
                                // Update current conditions with the latest data point
                                const latestPoint = newData[newData.length - 1];
                                updateCurrentConditions({
                                    timestamp: latestPoint[0],
                                    direction: latestPoint[1],
                                    speed_kts: latestPoint[2],
                                    gust_kts: latestPoint[3]
                                });
                            } else {
                                console.log('No new data points after deduplication');
                            }
                        } else {
                            console.log('No gap data retrieved');
                        }
                    } catch (error) {
                        console.error('Error filling data gap:', error);
                    }
                }

                function updateConnectionStatus(status, text) {
                    const statusElement = document.getElementById('connection-status');
                    statusElement.title = text;
                    statusElement.className = `connection-indicator ${status}`;
                    console.log(`WebSocket status: ${text}`);
                }

                function connectWebSocket() {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/${STATION}`;

                    updateConnectionStatus('connecting', 'Connecting...');

                    websocket = new WebSocket(wsUrl);

                    websocket.onopen = function(event) {
                        console.log('WebSocket connected successfully');
                        updateConnectionStatus('connected', 'Connected');

                        // Fill any data gap that occurred during disconnection
                        fillDataGap();
                    };

                    websocket.onmessage = function(event) {
                        console.log('WebSocket message received:', event.data);

                        try {
                            const data = JSON.parse(event.data);

                            // Handle ping messages
                            if (data.type === 'ping') {
                                console.log('Received ping from server');
                                updateConnectionStatus('connected', 'Connected');
                                return;
                            }

                            // Update status to show we're receiving data
                            updateConnectionStatus('connected', 'Connected (Live)');

                            if (!realtimeEnabled) return;

                            // Handle wind data messages
                            if (data.timestamp !== undefined) {
                                updateCurrentConditions(data);

                                // Check for duplicate data points before adding
                                const newPoint = [data.timestamp, data.direction, data.speed_kts, data.gust_kts];
                                const isDuplicate = windData.some(existingPoint =>
                                    Math.abs(existingPoint[0] - newPoint[0]) < 1 // Within 1 second
                                );

                                if (!isDuplicate) {
                                    console.log('New wind data point:', newPoint);
                                    windData.push(newPoint);

                                    // Sort by timestamp to maintain chronological order
                                    windData.sort((a, b) => a[0] - b[0]);

                                    // Filter out observations older than the selected time window
                                    windData = filterOldObservations(windData);

                                    // Keep only recent data (last 1000 points)
                                    if (windData.length > 1000) {
                                        windData = windData.slice(-1000);
                                    }

                                    updateCharts(windData);
                                } else {
                                    console.log('Discarding duplicate wind data point:', newPoint);
                                }
                            } else {
                                console.log('Received unknown message type:', data);
                            }
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                        }
                    };

                    websocket.onclose = function(event) {
                        console.log('WebSocket closed:', event.code, event.reason);
                        updateConnectionStatus('disconnected', 'Disconnected');

                        // Attempt to reconnect after 5 seconds
                        setTimeout(() => {
                            console.log('Attempting to reconnect...');
                            connectWebSocket();
                        }, 5000);
                    };

                    websocket.onerror = function(error) {
                        console.error('WebSocket error:', error);
                        updateConnectionStatus('error', 'Connection Error');
                    };
                }

                // Function to get yesterday's date in YYYY-MM-DD format
                function getYesterdayDate() {
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const year = yesterday.getFullYear();
                    const month = String(yesterday.getMonth() + 1).padStart(2, '0');
                    const day = String(yesterday.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }

                // Event listeners
                {% if is_live %}
                document.getElementById('toggle-realtime').addEventListener('click', function() {
                    realtimeEnabled = !realtimeEnabled;
                    this.textContent = realtimeEnabled ? 'Pause Real-time Updates' : 'Resume Real-time Updates';
                    this.className = realtimeEnabled ? 'btn' : 'btn paused';
                });

                document.getElementById('view-yesterday').addEventListener('click', function() {
                    const yesterdayDate = getYesterdayDate();
                    navigateToDate(yesterdayDate);
                });
                {% endif %}

                // Reset zoom button event listener
                document.getElementById('reset-zoom').addEventListener('click', function() {
                    resetZoom();
                });

                {% if is_live %}
                document.getElementById('time-range').addEventListener('change', function() {
                    const hours = parseInt(this.value);
                    currentTimeWindowHours = hours; // Update the current time window
                    {% if is_live %}
                    loadHistoricalData(hours);
                    {% else %}
                    // For date view, navigate to same date with new hours parameter
                    const currentParams = new URLSearchParams(window.location.search);
                    currentParams.set('hours', hours);
                    window.location.search = currentParams.toString();
                    {% endif %}
                });
                {% endif %}

                // Initialize the application
                document.addEventListener('DOMContentLoaded', function() {
                    // Initialize the current time window from template
                    currentTimeWindowHours = {{ hours }};
                    
                    {% if not is_live %}
                    // Format the selected date with weekday
                    const dateElement = document.getElementById('formatted-date');
                    if (dateElement) {
                        const date = new Date('{{ selected_date }}');
                        const options = {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric'
                        };
                        dateElement.textContent = date.toLocaleDateString('en-US', options);
                    }
                    {% endif %}

                    // Check if we should show the orientation popup
                    checkOrientationPopup();

                    initCharts();
                    loadHistoricalData({{ hours }});
                    {% if is_live %}
                    connectWebSocket();
                    {% endif %}
                });

                // Handle orientation changes
                window.addEventListener('orientationchange', function() {
                    // Hide popup if user rotates to landscape
                    setTimeout(function() {
                        if (!isPortraitOrientation()) {
                            hideOrientationPopup();
                        }
                    }, 500); // Small delay to let orientation change complete
                });

                // Handle window resize (for desktop testing)
                window.addEventListener('resize', function() {
                    if (!isPortraitOrientation()) {
                        hideOrientationPopup();
                    }
                });
        </script>
    </body>
</html>
